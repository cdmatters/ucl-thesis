
\chapter{Dataset Examples}
\label{example_datapoint}
% Figure \ref{lst:single_point} shows a real example of a datapoint in YAML markup. 
% Different parts of the data were used in the investigation.
\begin{listing}[h!]
\begin{minted}[]{yaml}
-   arg_name: tensors                                 # argument name: STRING
    arg_desc: ' a list of variable or op tensors.'    # argument description:Â STRING
    arg_type: null                                    # argument type: STRING or NULL
    args: [tensors, prefix]                           # list of arguments: LIST of STRING
    arg_info:                                         # info on other arguments: DICT of DICT
        prefix: 
            desc: ' An optional prefix for the summary names.' 
            type: null
    filename: /tensorflow/contrib/slim/python/slim/summaries.py  # filename: STRING
    name: add_zero_fraction_summaries                 # function name: STRING 
    sig: (tensors, prefix=None)                       # function signature: STRING
    pkg: tensorflow                                   # library: STRING  
    src: |                                            # source code: STRING 
      def add_zero_fraction_summaries(tensors, prefix=None):
        """Adds a scalar zero-fraction summary for each of the given tensors.
  
        Args:
          tensors: a list of variable or op tensors.
          prefix: An optional prefix for the summary names.
  
        Returns:
          A list of scalar `Tensors` of type `string` whose contents are the
          serialized `Summary` protocol buffer.
        """
        summary_ops = []
        for tensor in tensors:
          summary_ops.append(add_zero_fraction_summary(tensor, prefix=prefix))
        return summary_ops
    docstring: |                                      # sphinx annotated docstring: STRING 
      Adds a scalar zero-fraction summary for each of the given tensors.

      :param tensors: a list of variable or op tensors.
      :param prefix: An optional prefix for the summary names.

      :returns: A list of scalar `Tensors` of type `string` whose contents are the
                 serialized `Summary` protocol buffer.
\end{minted}
     \caption{Real example of a single data point, with all metadata. The docstring in the source has been elided for brevity}
     \label{lst:single_point}
\end{listing}

\begin{table}[h]
    \begin{center}
    \begin{tabular}{c | c | c }       
 Arg. Name (Total) & Top 5 Descriptions & Count\\
\hline
name   (1917) &  a name for the operation (optional).                                & 1057\\
&  optional op name.                                                   & 69 \\
&  an optional variable\_scope name.                                    & 41 \\
&  a name for this operation (optional).                               & 37 \\
&  a string, the name of the layer.                                    & 31 \\

\\
\hline
x   (439) &  tensor or variable.                                                 & 32 \\
&  a tensor or variable.                                               & 17 \\
&  `bfloat16`, `half`, `float32`, `float64`, `complex64`, `com[...]   & 14 \\
&  numeric `tensor`.                                                   & 12 \\
&  array or sequence containing the data                               & 10 \\

 \\
\hline
kwargs   (303) &  additional keyword arguments which will be passed to the ap[...]   & 12 \\
& optional arguments that ``request`` takes.                          & 11 \\
& standard layer keyword arguments.                                   & 8 \\
& additional properties to be set on the :class:`~.google.clo[...]   & 7 \\
& keyword arguments to pass to base method.                           & 5 \\

\\
\hline
axis   (263)  &  axis to broadcast over                                              & 14 \\
& the dimensions to reduce. if `none` (the default), reduces [...]   & 7 \\
& the index or the name of the axis. 0 is equivalent to none [...]   & 4 \\
& a `tensor` of type `int64`.                                         & 4 \\
& the axis or axes that were summed.                                  & 4 \\

\\
\hline
dtype   (260) &  a `tf.dtype`.                                                       & 11 \\
& the data type. only floating point types are supported.             & 8 \\
& default data type for internal matrices. set to np.float32 [...]   & 7 \\
& the type of the output.                                             & 6 \\
& overrides the data type of the result.                              & 6 \\


    \end{tabular}
        \caption { A table of the count and frequency of function names of the variables as they feature in the raw dataset. 
        These can be either due to the repetition of function name throughout libraries, or by one argument contributing many functions }
    \label{table:descriptions_for_names} 
    \end{center}
\end{table}

\begin{table}[h]
    \begin{center}
    \begin{tabular}{c | c | c | c | c | c | c | c | c  }       

 Variable Name &name         & &  x            &  & kwargs   & &  axis    \\
\hline
Top 5 Libraries  &tensorflow         & 1654     & tensorflow    & 300       & tensorflow    & 62       & tensorflow    & 85 \\
&google             & 51       & matplotlib    & 43       & google        & 47       & pandas        & 61       \\
&tflearn            & 50       & scipy         & 35       & dask          & 23       & scipy         & 54       \\
&external           & 14       & tflearn       & 12       & mir\_eval     & 21       & dask          & 20       \\ 
&absl               & 13       & dask          & 9        & librosa       & 18       & librosa       & 17       \\



    \end{tabular}
        \caption { A table of the count and frequency of function names of the variables as they feature in the raw dataset. 
        These can be either due to the repetition of function name throughout libraries, or by one argument contributing many functions }
    \label{table:packages_for_names} 
    \end{center}
\end{table}